import Foundation

/// Exports a FeatureTree as a CadQuery Python script.
/// CadQuery has better support for parametric features than OpenSCAD.
public enum CadQueryExporter {

    /// Export a feature tree to CadQuery Python script.
    public static func export(_ tree: FeatureTree) -> String {
        var lines: [String] = [
            "# Generated by OpeniOSCAD",
            "# https://github.com/lotzabananas/Open_IOSCAD",
            "import cadquery as cq",
            "",
            "result = cq.Workplane(\"XY\")",
        ]

        var sketchProfiles: [FeatureID: [SketchElement]] = [:]
        var indent = ""

        for feature in tree.features {
            guard !feature.isSuppressed else { continue }

            switch feature {
            case .sketch(let sketch):
                sketchProfiles[sketch.id] = sketch.elements

            case .extrude(let extrude):
                if let elements = sketchProfiles[extrude.sketchID] {
                    let profileCode = exportSketchProfile(elements)
                    lines.append("\(indent)result = result")
                    lines.append("    \(profileCode)")
                    if extrude.operation == .subtractive {
                        lines.append("    .cutBlind(\(formatNum(-extrude.depth)))")
                    } else {
                        lines.append("    .extrude(\(formatNum(extrude.depth)))")
                    }
                }

            case .revolve(let revolve):
                if let elements = sketchProfiles[revolve.sketchID] {
                    let profileCode = exportSketchProfile(elements)
                    lines.append("\(indent)result = result")
                    lines.append("    \(profileCode)")
                    lines.append("    .revolve(\(formatNum(revolve.angle)))")
                }

            case .transform(let transform):
                switch transform.transformType {
                case .translate:
                    lines.append("\(indent)result = result.translate((\(formatNum(transform.vectorX)), \(formatNum(transform.vectorY)), \(formatNum(transform.vectorZ))))")
                case .rotate:
                    lines.append("\(indent)result = result.rotate((0, 0, 0), (\(formatNum(transform.axisX)), \(formatNum(transform.axisY)), \(formatNum(transform.axisZ))), \(formatNum(transform.angle)))")
                case .scale:
                    lines.append("\(indent)# Scale: (\(formatNum(transform.vectorX)), \(formatNum(transform.vectorY)), \(formatNum(transform.vectorZ)))")
                    lines.append("\(indent)# Note: CadQuery doesn't support non-uniform scale directly")
                case .mirror:
                    lines.append("\(indent)result = result.mirror(\"XY\")")
                }

            case .boolean(let boolean):
                switch boolean.booleanType {
                case .union:
                    lines.append("\(indent)# Union of \(boolean.targetIDs.count) bodies")
                case .difference:
                    lines.append("\(indent)# Difference operation")
                case .intersection:
                    lines.append("\(indent)# Intersection operation")
                }

            case .fillet(let fillet):
                lines.append("\(indent)result = result.edges().fillet(\(formatNum(fillet.radius)))")

            case .chamfer(let chamfer):
                lines.append("\(indent)result = result.edges().chamfer(\(formatNum(chamfer.distance)))")

            case .shell(let shell):
                lines.append("\(indent)result = result.shell(\(formatNum(shell.thickness)))")

            case .pattern(let pattern):
                switch pattern.patternType {
                case .linear:
                    lines.append("\(indent)# Linear pattern: \(pattern.count) copies, spacing \(formatNum(pattern.spacing))")
                    lines.append("\(indent)copies = []")
                    lines.append("\(indent)for i in range(\(pattern.count)):")
                    lines.append("\(indent)    copies.append(result.translate((\(formatNum(pattern.directionX * pattern.spacing)) * i, \(formatNum(pattern.directionY * pattern.spacing)) * i, \(formatNum(pattern.directionZ * pattern.spacing)) * i)))")
                case .circular:
                    lines.append("\(indent)# Circular pattern: \(pattern.count) copies over \(formatNum(pattern.totalAngle))Â°")
                    lines.append("\(indent)copies = []")
                    lines.append("\(indent)for i in range(\(pattern.count)):")
                    lines.append("\(indent)    angle = \(formatNum(pattern.totalAngle)) / \(pattern.count) * i")
                    lines.append("\(indent)    copies.append(result.rotate((0,0,0), (\(formatNum(pattern.axisX)),\(formatNum(pattern.axisY)),\(formatNum(pattern.axisZ))), angle))")
                case .mirror:
                    lines.append("\(indent)result = result.mirror(\"XY\")")
                }

            case .sweep:
                lines.append("\(indent)# Sweep: profile along path")
                lines.append("\(indent)# result = result.sweep(path, ...)")

            case .loft:
                lines.append("\(indent)# Loft: blend between profiles")
                lines.append("\(indent)# result = cq.Workplane().loft([profile1, profile2])")

            case .assembly(let assembly):
                lines.append("\(indent)# Assembly: \(assembly.name)")
                lines.append("\(indent)# \(assembly.memberFeatureIDs.count) member features")
            }
        }

        lines.append("")
        lines.append("show_object(result)")
        return lines.joined(separator: "\n")
    }

    // MARK: - Private

    private static func exportSketchProfile(_ elements: [SketchElement]) -> String {
        guard let first = elements.first else { return ".rect(10, 10)" }

        switch first {
        case .rectangle(_, _, let width, let height):
            return ".rect(\(formatNum(Double(width))), \(formatNum(Double(height))))"
        case .circle(_, _, let radius):
            return ".circle(\(formatNum(Double(radius))))"
        case .lineSegment, .arc:
            return ".rect(10, 10)  # Complex profile (simplified)"
        }
    }

    private static func formatNum(_ value: Double) -> String {
        if value == value.rounded() && abs(value) < 1e10 {
            return String(format: "%.0f", value)
        }
        return String(format: "%.4g", value)
    }
}
