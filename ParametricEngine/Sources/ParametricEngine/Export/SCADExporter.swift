import Foundation

/// Exports a FeatureTree as an OpenSCAD .scad script.
/// Features that can be expressed as OpenSCAD operations are exported as such.
/// Features without OpenSCAD equivalents (fillet, chamfer) are exported as polyhedra.
public enum SCADExporter {

    /// Export a feature tree to .scad format.
    public static func export(_ tree: FeatureTree) -> String {
        var lines: [String] = [
            "// Generated by OpeniOSCAD",
            "// https://github.com/lotzabananas/Open_IOSCAD",
            ""
        ]

        var sketchProfiles: [FeatureID: [SketchElement]] = [:]

        for feature in tree.features {
            guard !feature.isSuppressed else { continue }

            switch feature {
            case .sketch(let sketch):
                sketchProfiles[sketch.id] = sketch.elements
                lines.append("// Sketch: \(sketch.name)")

            case .extrude(let extrude):
                if let elements = sketchProfiles[extrude.sketchID] {
                    let profile = exportSketchProfile(elements)
                    let op = extrude.operation == .subtractive ? "difference() {\n    children();\n    " : ""
                    let closeOp = extrude.operation == .subtractive ? "\n}" : ""
                    lines.append("\(op)linear_extrude(height = \(formatNum(extrude.depth))) {")
                    lines.append("    \(profile)")
                    lines.append("}\(closeOp)")
                }

            case .revolve(let revolve):
                if let elements = sketchProfiles[revolve.sketchID] {
                    let profile = exportSketchProfile(elements)
                    let angle = revolve.angle
                    lines.append("rotate_extrude(angle = \(formatNum(angle))) {")
                    lines.append("    \(profile)")
                    lines.append("}")
                }

            case .transform(let transform):
                switch transform.transformType {
                case .translate:
                    lines.append("translate([\(formatNum(transform.vectorX)), \(formatNum(transform.vectorY)), \(formatNum(transform.vectorZ))])")
                case .rotate:
                    lines.append("rotate(a = \(formatNum(transform.angle)), v = [\(formatNum(transform.axisX)), \(formatNum(transform.axisY)), \(formatNum(transform.axisZ))])")
                case .scale:
                    lines.append("scale([\(formatNum(transform.vectorX)), \(formatNum(transform.vectorY)), \(formatNum(transform.vectorZ))])")
                case .mirror:
                    lines.append("mirror([\(formatNum(transform.vectorX)), \(formatNum(transform.vectorY)), \(formatNum(transform.vectorZ))])")
                }

            case .boolean(let boolean):
                switch boolean.booleanType {
                case .union:
                    lines.append("union() {")
                    lines.append("    // Boolean union of \(boolean.targetIDs.count) bodies")
                    lines.append("}")
                case .difference:
                    lines.append("difference() {")
                    lines.append("    // Boolean difference")
                    lines.append("}")
                case .intersection:
                    lines.append("intersection() {")
                    lines.append("    // Boolean intersection")
                    lines.append("}")
                }

            case .fillet(let fillet):
                lines.append("// Fillet: \(fillet.name) (radius=\(formatNum(fillet.radius)))")
                lines.append("// Note: Fillet is not directly supported in OpenSCAD")
                lines.append("// The geometry is approximated in the evaluated mesh")

            case .chamfer(let chamfer):
                lines.append("// Chamfer: \(chamfer.name) (distance=\(formatNum(chamfer.distance)))")
                lines.append("// Note: Chamfer is not directly supported in OpenSCAD")

            case .shell(let shell):
                lines.append("// Shell: \(shell.name) (thickness=\(formatNum(shell.thickness)))")
                lines.append("// Note: Shell is not directly supported in OpenSCAD")

            case .pattern(let pattern):
                switch pattern.patternType {
                case .linear:
                    lines.append("for (i = [0:\(pattern.count - 1)]) {")
                    lines.append("    translate([\(formatNum(pattern.directionX * pattern.spacing)) * i, \(formatNum(pattern.directionY * pattern.spacing)) * i, \(formatNum(pattern.directionZ * pattern.spacing)) * i])")
                    lines.append("        children();")
                    lines.append("}")
                case .circular:
                    lines.append("for (i = [0:\(pattern.count - 1)]) {")
                    lines.append("    rotate(a = \(formatNum(pattern.totalAngle)) / \(pattern.count) * i, v = [\(formatNum(pattern.axisX)), \(formatNum(pattern.axisY)), \(formatNum(pattern.axisZ))])")
                    lines.append("        children();")
                    lines.append("}")
                case .mirror:
                    lines.append("mirror([\(formatNum(pattern.directionX)), \(formatNum(pattern.directionY)), \(formatNum(pattern.directionZ))])")
                    lines.append("    children();")
                }
            }

            lines.append("")
        }

        return lines.joined(separator: "\n")
    }

    // MARK: - Private

    private static func exportSketchProfile(_ elements: [SketchElement]) -> String {
        // Convert sketch elements to OpenSCAD 2D primitives
        guard let first = elements.first else { return "square(1);" }

        switch first {
        case .rectangle(_, let origin, let width, let height):
            return "translate([\(formatNum(Double(origin.x))), \(formatNum(Double(origin.y)))]) square([\(formatNum(Double(width))), \(formatNum(Double(height)))]);"
        case .circle(_, let center, let radius):
            return "translate([\(formatNum(Double(center.x))), \(formatNum(Double(center.y)))]) circle(r = \(formatNum(Double(radius))));";
        case .lineSegment, .arc:
            // For complex profiles, use polygon
            return exportPolygonProfile(elements)
        }
    }

    private static func exportPolygonProfile(_ elements: [SketchElement]) -> String {
        var points: [(Double, Double)] = []
        for element in elements {
            switch element {
            case .rectangle(_, let origin, let width, let height):
                points.append((Double(origin.x), Double(origin.y)))
                points.append((Double(origin.x + width), Double(origin.y)))
                points.append((Double(origin.x + width), Double(origin.y + height)))
                points.append((Double(origin.x), Double(origin.y + height)))
            case .circle(_, let center, let radius):
                // Approximate circle with 32 points
                for i in 0..<32 {
                    let angle = Double(i) * 2.0 * .pi / 32.0
                    points.append((Double(center.x) + Double(radius) * cos(angle),
                                   Double(center.y) + Double(radius) * sin(angle)))
                }
            case .lineSegment(_, let start, let end):
                points.append((Double(start.x), Double(start.y)))
                points.append((Double(end.x), Double(end.y)))
            case .arc(_, let center, let radius, let startAngle, let sweepAngle):
                let steps = max(8, Int(abs(sweepAngle) / 10))
                for i in 0...steps {
                    let angle = Double(startAngle) + Double(sweepAngle) * Double(i) / Double(steps)
                    let rad = angle * .pi / 180.0
                    points.append((Double(center.x) + Double(radius) * cos(rad),
                                   Double(center.y) + Double(radius) * sin(rad)))
                }
            }
        }

        let pointStr = points.map { "[\(formatNum($0.0)), \(formatNum($0.1))]" }.joined(separator: ", ")
        return "polygon(points = [\(pointStr)]);"
    }

    private static func formatNum(_ value: Double) -> String {
        if value == value.rounded() && abs(value) < 1e10 {
            return String(format: "%.0f", value)
        }
        return String(format: "%.4g", value)
    }
}
